'use strict';

exports.__esModule = true;
exports.compareValues = exports.compareChunks = exports.stringCompare = exports.compareUnicode = exports.normalizeChunk = exports.compareNumbers = exports.parseNumber = exports.createChunksList = exports.createChunks = exports.convertToString = exports.setOrder = undefined;

var _regex = require('./regex');

var setOrder = function setOrder(order) {
  return function (value) {
    return order === 'desc' ? value * -1 : value;
  };
};

var convertToString = function convertToString(caseSensitive) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return (!caseSensitive && ('' + value).toLowerCase() || '' + value).replace(_regex.RE_LEADING_OR_TRAILING_WHITESPACES, '');
};

var createChunks = function createChunks(value) {
  return value.replace(_regex.RE_NUMBERS, '\0$1\0').replace(/\0$/, '').replace(/^\0/, '').split('\0');
};

// normalize spaces; find floats not starting with '0',
// string or 0, if not defined (Clint Priest)
var normalizeChunk = function normalizeChunk() {
  var chunk = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var chunksLength = arguments[1];

  if (!chunk) {
    return 0;
  }
  if (_regex.RE_INT_OR_FLOAT.test(chunk) && (!_regex.RE_LEADING_ZERO.test(chunk) || chunksLength === 1)) {
    return parseFloat(chunk);
  }
  return chunk.replace(_regex.RE_WHITESPACES, ' ').replace(_regex.RE_LEADING_OR_TRAILING_WHITESPACES, '') || 0;
};

var createChunksList = function createChunksList(value) {
  var chunks = createChunks(value).map(function (chunk, index, array) {
    return normalizeChunk(chunk, array.length);
  });
  return chunks;
};

var createChunksList_old = function createChunksList_old(valueX, valueY) {
  var chunksX = createChunks(valueX);
  var chunksY = createChunks(valueY);
  var chunksList = void 0;
  if (chunksX.length >= chunksY.length) {
    chunksList = chunksX.map(function (chunkX, index) {
      var normChunkX = normalizeChunk(chunkX, chunksX.length);
      var normChunkY = normalizeChunk(chunksY[index], chunksY.length);
      return [normChunkX, normChunkY];
    });
  } else {
    chunksList = chunksY.map(function (chunkY, index) {
      var normChunkX = normalizeChunk(chunksX[index], chunksX.length);
      var normChunkY = normalizeChunk(chunkY, chunksY.length);
      return [normChunkX, normChunkY];
    });
  }
  return chunksList;
};

// numeric, hex or date detection
var parseNumber = function parseNumber(value) {
  return parseFloat(value.match(_regex.RE_INT_OR_FLOAT)) || parseInt(value.match(_regex.RE_HEXADECIMAL), 16) || _regex.RE_DATE.test(value) && Date.parse(value) || undefined;
};

var compareNumbers = function compareNumbers(numberX, numberY) {
  if (numberX < numberY) {
    return -1;
  }
  if (numberX > numberY) {
    return 1;
  }
  return 0;
};

var compareUnicode = function compareUnicode(stringX, stringY) {
  var comp = stringX.localeCompare(stringY);
  return comp ? comp / Math.abs(comp) : 0;
};

var stringCompare = function stringCompare(stringX, stringY) {
  if (stringX < stringY) {
    return -1;
  }
  if (stringX > stringY) {
    return 1;
  }
  return 0;
};

var compareChunkPair = function compareChunkPair(comp, _ref) {
  var chunkX = _ref[0],
      chunkY = _ref[1];

  if (!comp) {
    if (typeof chunkX === 'number' && typeof chunkY === 'number') {
      var value = compareNumbers(chunkX, chunkY);
      if (value) {
        return value;
      }
    } else {
      // handle numeric vs string comparison - number < string
      if (typeof chunkX === 'number' || typeof chunkY === 'number') {
        return typeof chunkX === 'number' ? -1 : 1;
      }

      // if one of the chunks contains unicode, use locale comparison
      // else use common string comparison for performance reason
      if (_regex.RE_UNICODE_CHARACTERS.test(chunkX + chunkY) && chunkX.localeCompare) {
        var _value = compareUnicode(chunkX, chunkY);
        if (_value) {
          return _value;
        }
      } else {
        var _value2 = stringCompare(chunkX, chunkY);
        if (_value2) {
          return _value2;
        }
      }
    }
  }
  return comp;
};

var compareChunks = function compareChunks(chunksA, chunksB) {
  return createChunksList(valueX, valueY).reduce(compareChunkPair, 0);
};

var compareValues = function compareValues(valueA, valueB) {
  var result = void 0;
  // first try and sort Hex codes or Dates
  if (valueA.parsedNumber !== undefined && valueB.parsedNumber !== undefined) {
    result = compareNumbers(valueA.parsedNumber, valueB.parsedNumber);
  } else {
    // natural sorting through split numeric strings and default strings
    result = compareChunks(valueA.chunks, valueA.chunks);
  }
  return result;
};

exports.setOrder = setOrder;
exports.convertToString = convertToString;
exports.createChunks = createChunks;
exports.createChunksList = createChunksList;
exports.parseNumber = parseNumber;
exports.compareNumbers = compareNumbers;
exports.normalizeChunk = normalizeChunk;
exports.compareUnicode = compareUnicode;
exports.stringCompare = stringCompare;
exports.compareChunks = compareChunks;
exports.compareValues = compareValues;